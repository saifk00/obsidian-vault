## Core Ontological Commitments

### Friction Reduction as Fundamental Good
"Reducing friction between things is more harmonious and we should choose the path of less friction for things to be 'better'."

Compilers are fundamentally **friction-reducing machines** between ontological layers:
- Between human thought and machine execution
- Between domain expertise and systems optimization
- Between theoretical algorithms and practical constraints
- Between individual programmer effort and collective computational capability

### Technology as Social Reorganization
Technologies solve human problems as much as technical ones. Compilers reorganize human labor - instead of every team needing systems optimization experts, these skills are centralized and serve entire ecosystems.

This connects to Marx's commodity fetishism: compilation systems appear as purely technical objects, but they actually embody and reorganize social relations of production and expertise.

### Truth Through "Labor of Thought"
Following Hegel: "Truth cannot be known in immediate apprehension... but only through the labour of thought."

Theoretical computability requires the "labor" of optimization to become practically computable. The gap between theory and practice isn't just technical - it requires genuine intellectual work to bridge.

### Platform vs Application Thinking
Interest in building foundational systems that enable others rather than just using existing tools. Working at the layer where individual optimizations get multiplied across entire ecosystems.

### Against Pure Abstraction
Drawn to "philosophical mode of thinking" but insisting it be **useful**. Compiler work bridges abstract theory (algorithms, formal systems) with concrete reality (hardware constraints, energy limits, economic pressures).

## Why These Problems Are Intrinsically Interesting

### Mediating Between Orders of Reality
- **Mathematical/Logical Order**: Algorithms, formal systems, theoretical computability
- **Physical Order**: Silicon, electricity, thermodynamics, actual hardware
- **Social Order**: Human labor, expertise distribution, economic efficiency
- **Temporal Order**: Real-time constraints, human attention spans, research cycles

Compiler engineers work at the intersection of all these orders of reality.

### Enabling Higher-Order Human Activity
By reducing computational friction, compiler work enables humans to operate at higher levels of abstraction - physicists can focus on physics rather than GPU programming, biologists on biology rather than distributed systems.

This is fundamentally about **human flourishing** through technological mediation.

### Fundamental Questions About Computation and Reality
- What does it mean for something to be "computable" in theory vs practice?
- How do we bridge the gap between mathematical ideality and physical constraints?
- What is the relationship between optimization and truth?
- How do abstraction layers shape human activity and consciousness?

## The Koan-Like Mission
"Aiming to bridge the gap between the theoretically and practically computable."

This captures the essential tension: many things are theoretically possible but practically impossible. The work is to find ways to make the practically impossible become practically feasible - expanding the boundary of what can actually be computed at scale.

This is not just engineering optimization - it's a fundamental question about the relationship between ideal and real, between what we can conceive and what we can achieve.